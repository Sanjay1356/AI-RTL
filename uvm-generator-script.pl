#!/usr/bin/perl
use strict;
use warnings;
use JSON;

# Get args
my $testcases_file = $ARGV[0] or die "Usage: $0 <testcases_json_file>\n";
my $output_dir = $ARGV[1] || ".";
mkdir $output_dir unless -d $output_dir;

# Load test cases
open(my $json_fh, '<', $testcases_file) or die "Cannot open $testcases_file: $!";
my $json_text = do { local $/; <$json_fh> };
close($json_fh);
my $data = decode_json($json_text);
my $module_name = $data->{module_name};
my $test_cases = $data->{test_cases};

# Extract IO ports from test cases
my $io_data = {
    inputs => [],
    outputs => [],
    inouts => []
};

# Extract input ports from test cases
my %seen_inputs;
my %seen_outputs;
foreach my $tc (@$test_cases) {
    foreach my $input (keys %{$tc->{inputs}}) {
        next if $seen_inputs{$input};
        $seen_inputs{$input} = 1;
        # Basic width detection from test pattern
        my $width = 1;
        if ($tc->{inputs}->{$input} =~ /(\d+)'b/) {
            $width = $1;
        }
        push @{$io_data->{inputs}}, {name => $input, width => $width};
    }
    
    foreach my $output (keys %{$tc->{expected_outputs}}) {
        next if $seen_outputs{$output};
        $seen_outputs{$output} = 1;
        my $width = 1;
        if ($tc->{expected_outputs}->{$output} =~ /(\d+)'b/) {
            $width = $1;
        }
        push @{$io_data->{outputs}}, {name => $output, width => $width};
    }
}

# Generate UVM template files
my @files = qw(if seq_item sequence sequencer driver monitor agent scoreboard env test tb_top);
foreach my $file (@files) {
    generate_file($file);
}

print "UVM files generated in $output_dir\n";

# Common function to handle file generation
sub generate_file {
    my $type = shift;
    my $filename = "$output_dir/${module_name}_$type.sv";
    open(my $fh, '>', $filename) or die "Cannot create $filename: $!";
    
    # File header
    print $fh "// $module_name $type - Generated by UVM Generator\n\n";
    
    if ($type eq 'if') {
        gen_if($fh);
    } elsif ($type eq 'seq_item') {
        gen_seq_item($fh);
    } elsif ($type eq 'sequence') {
        gen_sequence($fh);
    } elsif ($type eq 'sequencer') {
        gen_sequencer($fh);
    } elsif ($type eq 'driver') {
        gen_driver($fh);
    } elsif ($type eq 'monitor') {
        gen_monitor($fh);
    } elsif ($type eq 'agent') {
        gen_agent($fh);
    } elsif ($type eq 'scoreboard') {
        gen_scoreboard($fh);
    } elsif ($type eq 'env') {
        gen_env($fh);
    } elsif ($type eq 'test') {
        gen_test($fh);
    } elsif ($type eq 'tb_top') {
        gen_tb_top($fh);
    }
    
    close($fh);
}

# Helper to convert Verilog literals to sv/perl values
sub convert_literal {
    my $value = shift;
    $value =~ s/(\d+)'h([0-9a-fA-F]+)/0x$2/;
    $value =~ s/(\d+)'b([01]+)/0b$2/;
    $value =~ s/(\d+)'d(\d+)/$2/;
    return $value;
}

# Generate interface
sub gen_if {
    my $fh = shift;
    print $fh "interface ${module_name}_if(input logic clk, input logic rst_n);\n";
    
    # Declare signals
    foreach my $port (@{$io_data->{inputs}}) {
        print $fh "  logic ".($port->{width} > 1 ? "[".($port->{width}-1).":0] " : "")."$port->{name};\n";
    }
    foreach my $port (@{$io_data->{outputs}}) {
        print $fh "  logic ".($port->{width} > 1 ? "[".($port->{width}-1).":0] " : "")."$port->{name};\n";
    }
    
    # Clocking blocks
    print $fh "\n  clocking driver_cb @(posedge clk);\n    output ";
    print $fh join(", ", map { $_->{name} } @{$io_data->{inputs}}), ";\n  endclocking\n";
    
    print $fh "\n  clocking monitor_cb @(posedge clk);\n    input ";
    print $fh join(", ", 
        (map { $_->{name} } @{$io_data->{inputs}}),
        (map { $_->{name} } @{$io_data->{outputs}})), ";\n  endclocking\n";
    
    print $fh "\n  modport DRIVER (clocking driver_cb, input clk, rst_n);\n";
    print $fh "  modport MONITOR (clocking monitor_cb, input clk, rst_n);\n";
    print $fh "endinterface\n";
}

# Generate sequence item
sub gen_seq_item {
    my $fh = shift;
    print $fh "class ${module_name}_seq_item extends uvm_sequence_item;\n\n";
    
    # Input/output signals
    foreach my $port (@{$io_data->{inputs}}) {
        print $fh "  rand bit ".($port->{width} > 1 ? "[".($port->{width}-1).":0] " : "")."$port->{name};\n";
    }
    foreach my $port (@{$io_data->{outputs}}) {
        print $fh "  bit ".($port->{width} > 1 ? "[".($port->{width}-1).":0] " : "")."$port->{name};\n";
    }
    
    # Factory registration
    print $fh "\n  `uvm_object_utils_begin(${module_name}_seq_item)\n";
    foreach my $port ((@{$io_data->{inputs}}, @{$io_data->{outputs}})) {
        print $fh "    `uvm_field_int($port->{name}, UVM_ALL_ON)\n";
    }
    print $fh "  `uvm_object_utils_end\n\n";
    
    # Constructor
    print $fh "  function new(string name = \"${module_name}_seq_item\");\n";
    print $fh "    super.new(name);\n  endfunction\n";
    
    print $fh "endclass\n";
}

# Generate sequence
sub gen_sequence {
    my $fh = shift;
    
    # Base sequence
    print $fh "class ${module_name}_base_sequence extends uvm_sequence #(${module_name}_seq_item);\n";
    print $fh "  `uvm_object_utils(${module_name}_base_sequence)\n";
    print $fh "  function new(string name = \"${module_name}_base_sequence\");\n";
    print $fh "    super.new(name);\n  endfunction\n\n";
    
    print $fh "  task body();\n";
    print $fh "    ${module_name}_seq_item req;\n";
    print $fh "    repeat(5) begin\n";
    print $fh "      req = ${module_name}_seq_item::type_id::create(\"req\");\n";
    print $fh "      start_item(req); assert(req.randomize()); finish_item(req);\n";
    print $fh "    end\n  endtask\n";
    print $fh "endclass\n\n";
    
    # Test specific sequences
    foreach my $tc (@$test_cases) {
        my $tc_name = $tc->{test_id};
        print $fh "class ${module_name}_${tc_name}_sequence extends ${module_name}_base_sequence;\n";
        print $fh "  `uvm_object_utils(${module_name}_${tc_name}_sequence)\n";
        print $fh "  function new(string name = \"${module_name}_${tc_name}_sequence\");\n";
        print $fh "    super.new(name);\n  endfunction\n\n";
        
        print $fh "  task body();\n";
        print $fh "    ${module_name}_seq_item req;\n";
        print $fh "    req = ${module_name}_seq_item::type_id::create(\"req\");\n";
        print $fh "    start_item(req);\n";
        
        foreach my $input_name (keys %{$tc->{inputs}}) {
            print $fh "    req.$input_name = ".convert_literal($tc->{inputs}->{$input_name}).";\n";
        }
        
        print $fh "    finish_item(req);\n  endtask\n";
        print $fh "endclass\n\n";
    }
}

# Generate sequencer
sub gen_sequencer {
    my $fh = shift;
    print $fh "class ${module_name}_sequencer extends uvm_sequencer #(${module_name}_seq_item);\n";
    print $fh "  `uvm_component_utils(${module_name}_sequencer)\n";
    print $fh "  function new(string name = \"${module_name}_sequencer\", uvm_component parent = null);\n";
    print $fh "    super.new(name, parent);\n  endfunction\n";
    print $fh "endclass\n";
}

# Generate driver
sub gen_driver {
    my $fh = shift;
    print $fh "class ${module_name}_driver extends uvm_driver #(${module_name}_seq_item);\n";
    print $fh "  `uvm_component_utils(${module_name}_driver)\n";
    print $fh "  virtual ${module_name}_if vif;\n\n";
    
    print $fh "  function new(string name = \"${module_name}_driver\", uvm_component parent = null);\n";
    print $fh "    super.new(name, parent);\n  endfunction\n\n";
    
    print $fh "  function void build_phase(uvm_phase phase);\n";
    print $fh "    super.build_phase(phase);\n";
    print $fh "    if (!uvm_config_db#(virtual ${module_name}_if)::get(this, \"\", \"vif\", vif))\n";
    print $fh "      `uvm_fatal(\"NOVIF\", \"Interface not found\")\n  endfunction\n\n";
    
    print $fh "  task run_phase(uvm_phase phase);\n";
    print $fh "    @(posedge vif.rst_n);\n";
    print $fh "    forever begin\n";
    print $fh "      seq_item_port.get_next_item(req);\n";
    print $fh "      drive_item(req);\n";
    print $fh "      seq_item_port.item_done();\n";
    print $fh "    end\n  endtask\n\n";
    
    print $fh "  task drive_item(${module_name}_seq_item item);\n";
    print $fh "    @(vif.driver_cb);\n";
    foreach my $port (@{$io_data->{inputs}}) {
        print $fh "    vif.driver_cb.$port->{name} <= item.$port->{name};\n";
    }
    print $fh "    @(vif.driver_cb);\n  endtask\n";
    print $fh "endclass\n";
}

# Generate monitor
sub gen_monitor {
    my $fh = shift;
    print $fh "class ${module_name}_monitor extends uvm_monitor;\n";
    print $fh "  `uvm_component_utils(${module_name}_monitor)\n";
    print $fh "  virtual ${module_name}_if vif;\n";
    print $fh "  uvm_analysis_port #(${module_name}_seq_item) item_collected_port;\n\n";
    
    print $fh "  function new(string name = \"${module_name}_monitor\", uvm_component parent = null);\n";
    print $fh "    super.new(name, parent);\n";
    print $fh "    item_collected_port = new(\"item_collected_port\", this);\n  endfunction\n\n";
    
    print $fh "  function void build_phase(uvm_phase phase);\n";
    print $fh "    super.build_phase(phase);\n";
    print $fh "    if (!uvm_config_db#(virtual ${module_name}_if)::get(this, \"\", \"vif\", vif))\n";
    print $fh "      `uvm_fatal(\"NOVIF\", \"Interface not found\")\n  endfunction\n\n";
    
    print $fh "  task run_phase(uvm_phase phase);\n";
    print $fh "    @(posedge vif.rst_n);\n";
    print $fh "    forever begin\n";
    print $fh "      ${module_name}_seq_item item = ${module_name}_seq_item::type_id::create(\"item\");\n";
    print $fh "      @(vif.monitor_cb);\n";
    foreach my $port (@{$io_data->{inputs}}) {
        print $fh "      item.$port->{name} = vif.monitor_cb.$port->{name};\n";
    }
    foreach my $port (@{$io_data->{outputs}}) {
        print $fh "      item.$port->{name} = vif.monitor_cb.$port->{name};\n";
    }
    print $fh "      item_collected_port.write(item);\n";
    print $fh "    end\n  endtask\n";
    print $fh "endclass\n";
}

# Generate agent
sub gen_agent {
    my $fh = shift;
    print $fh "class ${module_name}_agent extends uvm_agent;\n";
    print $fh "  `uvm_component_utils(${module_name}_agent)\n";
    print $fh "  ${module_name}_driver    driver;\n";
    print $fh "  ${module_name}_sequencer sequencer;\n";
    print $fh "  ${module_name}_monitor   monitor;\n";
    print $fh "  uvm_active_passive_enum is_active = UVM_ACTIVE;\n\n";
    
    print $fh "  function new(string name = \"${module_name}_agent\", uvm_component parent = null);\n";
    print $fh "    super.new(name, parent);\n  endfunction\n\n";
    
    print $fh "  function void build_phase(uvm_phase phase);\n";
    print $fh "    super.build_phase(phase);\n";
    print $fh "    monitor = ${module_name}_monitor::type_id::create(\"monitor\", this);\n";
    print $fh "    if (is_active == UVM_ACTIVE) begin\n";
    print $fh "      driver = ${module_name}_driver::type_id::create(\"driver\", this);\n";
    print $fh "      sequencer = ${module_name}_sequencer::type_id::create(\"sequencer\", this);\n";
    print $fh "    end\n  endfunction\n\n";
    
    print $fh "  function void connect_phase(uvm_phase phase);\n";
    print $fh "    if (is_active == UVM_ACTIVE)\n";
    print $fh "      driver.seq_item_port.connect(sequencer.seq_item_export);\n";
    print $fh "  endfunction\n";
    print $fh "endclass\n";
}

# Generate scoreboard
sub gen_scoreboard {
    my $fh = shift;
    print $fh "class ${module_name}_scoreboard extends uvm_scoreboard;\n";
    print $fh "  `uvm_component_utils(${module_name}_scoreboard)\n";
    print $fh "  uvm_tlm_analysis_fifo #(${module_name}_seq_item) item_fifo;\n";
    print $fh "  ${module_name}_seq_item test_cases[$];\n";
    print $fh "  int num_passed = 0, num_failed = 0;\n\n";
    
    print $fh "  function new(string name = \"${module_name}_scoreboard\", uvm_component parent = null);\n";
    print $fh "    super.new(name, parent);\n";
    print $fh "    item_fifo = new(\"item_fifo\", this);\n";
    print $fh "    init_test_cases();\n  endfunction\n\n";
    
    print $fh "  function void init_test_cases();\n";
    print $fh "    ${module_name}_seq_item item;\n";
    
    foreach my $tc (@$test_cases) {
        print $fh "    item = ${module_name}_seq_item::type_id::create(\"item\");\n";
        foreach my $input_name (keys %{$tc->{inputs}}) {
            print $fh "    item.$input_name = ".convert_literal($tc->{inputs}->{$input_name}).";\n";
        }
        foreach my $output_name (keys %{$tc->{expected_outputs}}) {
            print $fh "    item.$output_name = ".convert_literal($tc->{expected_outputs}->{$output_name}).";\n";
        }
        print $fh "    test_cases.push_back(item);\n\n";
    }
    print $fh "  endfunction\n\n";
    
    print $fh "  task run_phase(uvm_phase phase);\n";
    print $fh "    ${module_name}_seq_item item;\n";
    print $fh "    forever begin\n";
    print $fh "      item_fifo.get(item);\n";
    print $fh "      check_item(item);\n";
    print $fh "    end\n  endtask\n\n";
    
    print $fh "  task check_item(${module_name}_seq_item item);\n";
    print $fh "    bit found_match = 0;\n";
    print $fh "    foreach (test_cases[i]) begin\n";
    print $fh "      if (";
    
    my @input_checks = map { "item.$_->{name} == test_cases[i].$_->{name}" } @{$io_data->{inputs}};
    print $fh join(" && ", @input_checks), ") begin\n";
    
    print $fh "        found_match = 1;\n";
    print $fh "        if (";
    
    my @output_checks = map { "item.$_->{name} == test_cases[i].$_->{name}" } @{$io_data->{outputs}};
    print $fh join(" && ", @output_checks), ") begin\n";
    
    print $fh "          `uvm_info(get_type_name(), \"TEST PASSED\", UVM_LOW)\n";
    print $fh "          num_passed++;\n";
    print $fh "        end else begin\n";
    print $fh "          `uvm_error(get_type_name(), \"TEST FAILED - Output mismatch\")\n";
    print $fh "          num_failed++;\n";
    print $fh "        end\n";
    print $fh "        break;\n";
    print $fh "      end\n";
    print $fh "    end\n  endtask\n\n";
    
    print $fh "  function void report_phase(uvm_phase phase);\n";
    print $fh "    `uvm_info(get_type_name(), \$sformatf(\"Passed: %0d, Failed: %0d\", num_passed, num_failed), UVM_LOW)\n";
    print $fh "  endfunction\n";
    print $fh "endclass\n";
}

# Generate env
sub gen_env {
    my $fh = shift;
    print $fh "class ${module_name}_env extends uvm_env;\n";
    print $fh "  `uvm_component_utils(${module_name}_env)\n";
    print $fh "  ${module_name}_agent agent;\n";
    print $fh "  ${module_name}_scoreboard scoreboard;\n\n";
    
    print $fh "  function new(string name = \"${module_name}_env\", uvm_component parent = null);\n";
    print $fh "    super.new(name, parent);\n  endfunction\n\n";
    
    print $fh "  function void build_phase(uvm_phase phase);\n";
    print $fh "    super.build_phase(phase);\n";
    print $fh "    agent = ${module_name}_agent::type_id::create(\"agent\", this);\n";
    print $fh "    scoreboard = ${module_name}_scoreboard::type_id::create(\"scoreboard\", this);\n";
    print $fh "  endfunction\n\n";
    
    print $fh "  function void connect_phase(uvm_phase phase);\n";
    print $fh "    agent.monitor.item_collected_port.connect(scoreboard.item_fifo.analysis_export);\n";
    print $fh "  endfunction\n";
    print $fh "endclass\n";
}

# Generate test
sub gen_test {
    my $fh = shift;
    print $fh "class ${module_name}_base_test extends uvm_test;\n";
    print $fh "  `uvm_component_utils(${module_name}_base_test)\n";
    print $fh "  ${module_name}_env env;\n";
    print $fh "  virtual ${module_name}_if vif;\n\n";
    
    print $fh "  function new(string name = \"${module_name}_base_test\", uvm_component parent = null);\n";
    print $fh "    super.new(name, parent);\n  endfunction\n\n";
    
    print $fh "  function void build_phase(uvm_phase phase);\n";
    print $fh "    super.build_phase(phase);\n";
    print $fh "    env = ${module_name}_env::type_id::create(\"env\", this);\n";
    print $fh "    if (!uvm_config_db#(virtual ${module_name}_if)::get(this, \"\", \"vif\", vif))\n";
    print $fh "      `uvm_fatal(\"NOVIF\", \"Virtual interface not found\")\n";
    print $fh "    uvm_config_db#(virtual ${module_name}_if)::set(this, \"env.agent.*\", \"vif\", vif);\n";
    print $fh "  endfunction\n\n";
    
    print $fh "  task run_phase(uvm_phase phase);\n";
    print $fh "    phase.raise_objection(this);\n";
    print $fh "    phase.drop_objection(this);\n";
    print $fh "  endtask\n";
    print $fh "endclass\n\n";
    
    # Test-case specific tests
    foreach my $tc (@$test_cases) {
        my $tc_name = $tc->{test_id};
        print $fh "class ${module_name}_${tc_name}_test extends ${module_name}_base_test;\n";
        print $fh "  `uvm_component_utils(${module_name}_${tc_name}_test)\n\n";
        
        print $fh "  function new(string name = \"${module_name}_${tc_name}_test\", uvm_component parent = null);\n";
        print $fh "    super.new(name, parent);\n  endfunction\n\n";
        
        print $fh "  task run_phase(uvm_phase phase);\n";
        print $fh "    ${module_name}_${tc_name}_sequence seq;\n";
        print $fh "    phase.raise_objection(this);\n";
        print $fh "    seq = ${module_name}_${tc_name}_sequence::type_id::create(\"seq\");\n";
        print $fh "    #100; seq.start(env.agent.sequencer); #100;\n";
        print $fh "    phase.drop_objection(this);\n";
        print $fh "  endtask\n";
        print $fh "endclass\n\n";
    }
    
    # All tests
    print $fh "class ${module_name}_all_tests_test extends ${module_name}_base_test;\n";
    print $fh "  `uvm_component_utils(${module_name}_all_tests_test)\n\n";
    
    print $fh "  function new(string name = \"${module_name}_all_tests_test\", uvm_component parent = null);\n";
    print $fh "    super.new(name, parent);\n  endfunction\n\n";
    
    print $fh "  task run_phase(uvm_phase phase);\n";
    print $fh "    phase.raise_objection(this);\n";
    print $fh "    #100;\n";
    
    foreach my $tc (@$test_cases) {
        my $tc_name = $tc->{test_id};
        print $fh "    begin\n";
        print $fh "      ${module_name}_${tc_name}_sequence seq;\n";
        print $fh "      seq = ${module_name}_${tc_name}_sequence::type_id::create(\"seq_$tc_name\");\n";
        print $fh "      seq.start(env.agent.sequencer); #20;\n";
        print $fh "    end\n";
    }
    
    print $fh "    #100;\n";
    print $fh "    phase.drop_objection(this);\n";
    print $fh "  endtask\n";
    print $fh "endclass\n";
}

# Generate testbench top
sub gen_tb_top {
    my $fh = shift;
    print $fh "`include \"uvm_macros.svh\"\n";
    print $fh "import uvm_pkg::*;\n\n";
    
    # Include files
    print $fh "// Include UVM files\n";
    my @files = qw(if seq_item sequence sequencer driver monitor agent scoreboard env test);
    foreach my $file (@files) {
        print $fh "`include \"${module_name}_$file.sv\"\n";
    }
    print $fh "\n";
    
    # Top module
    print $fh "module ${module_name}_tb_top;\n";
    print $fh "  logic clk = 0, rst_n = 0;\n";
    print $fh "  always #5 clk = ~clk;\n";
    print $fh "  initial #50 rst_n = 1;\n\n";
    
    print $fh "  ${module_name}_if vif(clk, rst_n);\n\n";
    
    # DUT
    print $fh "  $module_name dut (\n";
    print $fh "    .clk(clk),\n";
    print $fh "    .rst_n(rst_n),\n";
    
    my @ports = (
        map { "    .$_->{name}(vif.$_->{name})" } @{$io_data->{inputs}},
        map { "    .$_->{name}(vif.$_->{name})" } @{$io_data->{outputs}}
    );
    print $fh join(",\n", @ports), "\n";
    print $fh "  );\n\n";
    
    print $fh "  initial begin\n";
    print $fh "    uvm_config_db#(virtual ${module_name}_if)::set(null, \"uvm_test_top\", \"vif\", vif);\n";
    print $fh "    run_test();\n";
    print $fh "  end\n";
    print $fh "endmodule\n";
}